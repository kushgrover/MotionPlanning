\subsection{Analysis}\label{sec:analysis}

%\begin{remark}
%    We assume that there are no prohibited\todo{Jan:I want to polish this (it's not even defined what we mean by prohibited, right? the example illustrates this but we need to clarify this)} regions in the environment since most of the applications require reaching a bunch of regions in some order and repeating this infinitely often. However, even if there were any prohibitions, we can still solve it by treating them like obstacles. 
%\end{remark}
%To illustrate the last remark, we give an example:
%\begin{example}
%    Let's assume there are three regions labelled with $a,b$ and $c$ as shown in fig \ref{}. If the property says that reach $c$ from $a$ while avoiding $b$, our algorithm can sample a point in $c$ and possibly add an edge from $a$ to $c$ directly but that edge will certainly go over $b$. To deal with this, we can simply treat labelled regions as obstacles and when we do collision checking, we also check if the edge crosses any of these regions in between.
%\end{example}

\begin{theorem}
The algorithm is sound, i.e. any trajectory returned by SAG-RRG satisfies the given scLTL formula $\spec$.
\end{theorem}
\begin{proof}
(Sketch) The proposed algorithm iteratively constructs a product MM-P (Def.~\ref{def:product}) between a semantic abstraction of the RRG graph and the automaton $\ba$, which accepts exactly the language of the specification $\spec$. Paths in the product that visit accepting states 
%infinitely many times 
project directly onto accepting runs of the automaton and runs of MM-TS, which in turn project directly onto paths in the RRG graph $G$ and further onto trajectories of the robot in the workspace. Altogether, these trajectories necessarily satisfy~$\spec$.
%Our algorithm attempts to bias the growth of the RRG graph towards faster convergence to an accepting state of the BA $\ba$ (Def.~\ref{def:buchi}); however, in the worst-case scenario, it performs as bad as exhaustive search. Once such an accepting state is reached, the undirected graph generated by the RRG guarantees the existence of a cyclic path that generates an (infinite) accepting word of BA $\ba$.
\end{proof}

\begin{theorem}
SAG-RRG is asymptotically complete.
\end{theorem}
\begin{proof}
(Sketch) Follows directly from the convergence and completeness properties of the original RRG \cite{karaman2011sampling} and the fact that the biasing we introduced allows to eventually sample the whole space. Regardless of the scenario, including the one with no regularity in the environment that can be learned and exploited for guiding the search, the worse-case scenario will see the proposed approach perform an exhaustive search of the environment.%\todo{J:I don't understand this sentence. F: Better?} %By using an exploration algorithm as a fallback to learn the labeling function $\labelling$ as well as the obstacle space, we allow the RRG graph to eventually cover the whole space. 
%Therefore, if there exists a trajectory in the environment that satisfies the LTL specification $\spec$, the proposed algorithm will find it eventually.
\end{proof}

%Since the path that algorithm returns is an accepting path in the product automaton, it is accepted in the property automaton. Hence it is correct. If an accepting path exists, the algorithm will eventually find it because we are generating an RRG graph which will contain all possible paths \todo{Jan: not really but this musy have occurred with standard RRG already; imagine a one dimensional line between two obstacles; also imagine reachability (F x) where x is a single point  - again, classical issue, Sweden probably knows how to comment on this, my view is to require `robust' solutions exist, i.e. after adding \emph{any} $\vec\varepsilon$ with $|\vec\varepsilon|<\delta$ it is still a solution} in the limit and if a correct path exists it will be found.
%\todo{Write that ldba only needs repeated reachability, which is doable in this setting. Jan: we need a lasso but we're never coming back exactly (must have occurred as an issue already with surveillance - GF)}


% The proof of this algorithm can be extended from the proof of correctness of the RRG algorithm. Since the bias is always finite, it can sample from bias for a finite number of times, after that the bias will become null and it will sample randomly. 
